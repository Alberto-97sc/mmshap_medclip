import os
import zipfile
from PIL import Image
from io import BytesIO
from typing import Dict, List
from collections import defaultdict
from mmshap_medclip.datasets.base import DatasetBase
from mmshap_medclip.registry import register_dataset

@register_dataset("vqa_med_2019")
def _build_vqa_med_2019(params):
    return VQAMed2019Dataset(**params)

class VQAMed2019Dataset(DatasetBase):
    """
    Dataset loader para VQA-Med 2019.
    
    Lee archivos del ZIP ImageClef-2019-VQA-Med-Training.zip o Validation.zip:
    - All_QA_Pairs_<split>.txt (contiene preguntas y respuestas)
    - directorio <images_subdir>/ (por defecto Train_images/ para Training, Val_images/ para Validation)
    
    Tambi√©n puede leer desde el ZIP padre (VQA-Med-2019.zip) que contiene los zips hijos.
    
    Infiere categor√≠as de preguntas y construye candidatos autom√°ticamente.
    """
    
    def __init__(
        self,
        zip_path: str,
        split: str = "Validation",
        images_subdir: str = None,
        n_rows: str = "all"
    ):
        """
        Args:
            zip_path: Ruta al archivo ZIP del dataset (puede ser el zip padre VQA-Med-2019.zip o el zip hijo)
            split: Split a usar ('Training', 'Validation', 'Test', etc.)
            images_subdir: Subdirectorio dentro del ZIP donde est√°n las im√°genes
                          Si es None, se infiere: "Train_images" para Training, "Val_images" para Validation, "Test_images" para Test
            n_rows: N√∫mero de filas a cargar ("all" o un entero)
        """
        self.zip_path = zip_path
        self.split = split
        
        # Inicializar candidates_per_cat como dict vac√≠o
        self.candidates_per_cat = {}
        
        # Inferir images_subdir si no se proporciona
        # Nota: El ZIP puede tener un directorio ra√≠z, as√≠ que buscamos en cualquier ubicaci√≥n
        if images_subdir is None:
            if split.lower() == "validation":
                self.images_subdir = "Val_images"
            elif split.lower() == "training" or split.lower() == "train":
                self.images_subdir = "Train_images"
            elif split.lower() == "test":
                self.images_subdir = "Test_images"
            else:
                self.images_subdir = f"{split}_images"
        else:
            self.images_subdir = images_subdir
        
        # Detectar si el zip_path es el zip padre (VQA-Med-2019.zip) que contiene zips hijos
        # En ese caso, necesitamos abrir el zip hijo correspondiente
        self.is_nested_zip = False
        self.inner_zip_name = None
        self.inner_zip_data = None  # Guardar el zip hijo en memoria para uso posterior
        
        # Verificar si es el zip padre
        zip_basename = os.path.basename(zip_path).lower()
        # Detectar si es el zip padre (VQA-Med-2019.zip)
        if "vqa-med-2019" in zip_basename and zip_basename.endswith(".zip"):
            self.is_nested_zip = True
            # Determinar el nombre del zip hijo seg√∫n el split
            if split.lower() in ["training", "train"]:
                self.inner_zip_name = "ImageClef-2019-VQA-Med-Training.zip"
            elif split.lower() == "validation":
                self.inner_zip_name = "ImageClef-2019-VQA-Med-Validation.zip"
            elif split.lower() == "test":
                self.inner_zip_name = "VQAMed2019Test.zip"
            else:
                # Intentar inferir desde el nombre del zip
                self.inner_zip_name = f"ImageClef-2019-VQA-Med-{split}.zip"
        
        # Detectar el prefijo de directorio ra√≠z del ZIP si existe
        # Por ejemplo: "ImageClef-2019-VQA-Med-Validation/"
        self.zip_root_prefix = None
        
        # Cargar preguntas y respuestas desde el ZIP
        # Si es un zip anidado, abrir el zip padre y luego el zip hijo
        if self.is_nested_zip:
            # Abrir el zip padre
            with zipfile.ZipFile(zip_path, "r") as parent_zip:
                # Verificar que el zip hijo existe
                if self.inner_zip_name not in parent_zip.namelist():
                    # Buscar con variaciones
                    found = False
                    for name in parent_zip.namelist():
                        if split.lower() in name.lower() and name.endswith(".zip"):
                            self.inner_zip_name = name
                            found = True
                            break
                    if not found:
                        raise FileNotFoundError(
                            f"No se encontr√≥ el zip hijo para split '{split}' en {zip_path}. "
                            f"Archivos disponibles: {parent_zip.namelist()[:10]}"
                        )
                
                # Leer el zip hijo en memoria y guardarlo para uso posterior
                self.inner_zip_data = parent_zip.read(self.inner_zip_name)
                # Abrir el zip hijo desde memoria
                zf = zipfile.ZipFile(BytesIO(self.inner_zip_data), "r")
        else:
            # Abrir directamente el zip hijo
            zf = zipfile.ZipFile(zip_path, "r")
        
        try:
            # Buscar archivo All_QA_Pairs_<split>.txt
            # Para Training: All_QA_Pairs_train.txt
            # Para Validation: All_QA_Pairs_val.txt
            # Para Test: All_QA_Pairs_test.txt
            qa_file = None
            split_lower = split.lower()
            
            # Lista de nombres posibles para el archivo (buscar en cualquier ubicaci√≥n)
            possible_names = [
                f"All_QA_Pairs_{split_lower}.txt",
                f"All_QA_Pairs_val.txt",  # Para Validation
                f"All_QA_Pairs_train.txt",  # Para Training
                f"All_QA_Pairs_test.txt",  # Para Test
                "All_QA_Pairs_val.txt",
                "All_QA_Pairs_train.txt",
                "All_QA_Pairs.txt",
            ]
            
            # Tambi√©n buscar en subdirectorios
            all_txt_files = [n for n in zf.namelist() if n.endswith(".txt")]
            all_files = zf.namelist()  # Todos los archivos para debugging
            
            # Detectar prefijo de directorio ra√≠z del ZIP (ej: "ImageClef-2019-VQA-Med-Validation/")
            # Buscar el directorio m√°s com√∫n en las rutas
            if all_files:
                # Obtener el primer directorio com√∫n
                first_file = all_files[0]
                if '/' in first_file:
                    # Extraer el prefijo del directorio ra√≠z
                    parts = first_file.split('/')
                    if len(parts) > 1:
                        self.zip_root_prefix = parts[0] + '/'
                        print(f"üìÇ Detectado prefijo de directorio en ZIP: {self.zip_root_prefix}")
            
            # PRIORIDAD 1: Buscar archivos QAPairsByCategory (C1_Modality_*, C2_Plane_*, etc.)
            # Estos archivos tienen prioridad sobre All_QA_Pairs
            category_files = []
            for name in all_txt_files:
                basename = os.path.basename(name)
                # Buscar archivos de categor√≠a: C1_Modality_train.txt, C2_Plane_val.txt, etc.
                # Verificar formato C1_*, C2_*, C3_*, C4_*
                # Tambi√©n verificar que est√©n en QAPairsByCategory o que el basename empiece con C
                if basename.startswith("C") and len(basename) > 1:
                    # Verificar si coincide con el split (train/val/test)
                    basename_lower = basename.lower()
                    # Normalizar split_lower para matching
                    split_normalized = split_lower
                    if split_lower in ["training", "train"]:
                        split_normalized = "train"
                    elif split_lower == "validation":
                        split_normalized = "val"
                    
                    split_match = (
                        split_normalized in basename_lower or
                        ("train" in basename_lower and split_lower in ["training", "train"]) or
                        ("val" in basename_lower and split_lower == "validation") or
                        ("test" in basename_lower and split_lower == "test")
                    )
                    if split_match:
                        category_files.append(name)
            
            # Si encontramos archivos por categor√≠a, usarlos (tienen prioridad)
            if category_files:
                qa_file = None  # Forzar uso de archivos por categor√≠a
                print(f"üìÅ Usando archivos por categor√≠a: {len(category_files)} archivos encontrados")
                print(f"   Archivos: {[os.path.basename(f) for f in category_files]}")
            else:
                # Estrategia 1: Buscar por nombre exacto (con y sin prefijo de directorio)
                # Buscar tanto en ra√≠z como en subdirectorios
                for name in all_txt_files:
                    basename = os.path.basename(name)
                    if basename in possible_names:
                        qa_file = name
                        break
                
                # Estrategia 2: Buscar por patr√≥n "All_QA_Pairs" + split (en cualquier ubicaci√≥n)
                if qa_file is None:
                    for name in all_txt_files:
                        basename = os.path.basename(name)
                        if "All_QA_Pairs" in basename and split_lower in basename.lower():
                            qa_file = name
                            break
                
                # Estrategia 3: Buscar cualquier archivo con "All_QA_Pairs" (en cualquier ubicaci√≥n)
                if qa_file is None:
                    for name in all_txt_files:
                        basename = os.path.basename(name)
                        if "All_QA_Pairs" in basename:
                            qa_file = name
                            break
            
            # Si no encontramos archivos por categor√≠a ni All_QA_Pairs, mostrar error
            if not category_files and qa_file is None:
                # Mostrar todos los archivos disponibles para debugging
                txt_files = [n for n in zf.namelist() if n.endswith(".txt")]
                # Mostrar tambi√©n estructura de directorios
                dirs = sorted(set([os.path.dirname(n) for n in zf.namelist() if os.path.dirname(n)]))
                
                error_msg = (
                    f"No se encontraron archivos de QA pairs para split '{split}' en el ZIP.\n"
                    f"Buscando archivos QAPairsByCategory (C1_*, C2_*, C3_*, C4_*) o All_QA_Pairs_*{split_lower}*.txt\n"
                    f"Archivos .txt disponibles ({len(txt_files)}):\n" +
                    "\n".join(f"  - {f}" for f in txt_files[:20]) +
                    (f"\n  ... y {len(txt_files) - 20} m√°s" if len(txt_files) > 20 else "") +
                    f"\n\nDirectorios en el ZIP ({len(dirs)}):\n" +
                    "\n".join(f"  - {d}" for d in dirs[:10]) +
                    (f"\n  ... y {len(dirs) - 10} m√°s" if len(dirs) > 10 else "")
                )
                raise FileNotFoundError(error_msg)
            
            # Leer archivo(s) de QA pairs
            # Priorizar archivos por categor√≠a si existen
            files_to_read = category_files if category_files else ([qa_file] if qa_file else [])
            
            if not files_to_read:
                raise FileNotFoundError("No se encontraron archivos de QA pairs para leer")
            
            # Formato esperado: image_id|question|answer
            self.samples = []
            
            for file_to_read in files_to_read:
                # Inferir categor√≠a desde el nombre del archivo
                basename = os.path.basename(file_to_read).lower()
                category = None
                
                if "c1" in basename or "modality" in basename:
                    category = "modality"
                elif "c2" in basename or "plane" in basename:
                    category = "plane"
                elif "c3" in basename or "organ" in basename:
                    category = "organ_system"
                elif "c4" in basename or "abnormality" in basename:
                    category = "abnormality"
                
                if category is None:
                    # Si no se puede inferir desde el nombre, saltar este archivo
                    print(f"‚ö†Ô∏è  Advertencia: No se pudo inferir categor√≠a desde {file_to_read}, saltando...")
                    continue
                
                with zf.open(file_to_read) as f:
                    for line_num, line in enumerate(f, 1):
                        line = line.decode('utf-8').strip()
                        if not line:
                            continue
                        
                        # Parsear formato: image_id|question|answer
                        try:
                            parts = line.split("|")
                            if len(parts) != 3:
                                if line_num <= 5:
                                    print(f"‚ö†Ô∏è  Advertencia: L√≠nea {line_num} no tiene formato image_id|question|answer: {line[:80]}")
                                continue
                            
                            image_id = parts[0].strip()
                            question = parts[1].strip()
                            answer = parts[2].strip()
                            
                            # Validar que tenemos los campos m√≠nimos
                            if not image_id or not question or not answer:
                                if line_num <= 5:
                                    print(f"‚ö†Ô∏è  Advertencia: Campos vac√≠os en l√≠nea {line_num}: {line[:80]}")
                                continue
                            
                            self.samples.append({
                                'question_id': image_id,  # Usar image_id como question_id
                                'question': question,
                                'answer': answer,
                                'category': category,  # Categor√≠a desde nombre de archivo
                                'image_filename': image_id  # image_id es el nombre de la imagen
                            })
                        except Exception as e:
                            if line_num <= 5:
                                print(f"‚ö†Ô∏è  Error parseando l√≠nea {line_num}: {e} - {line[:80]}")
                            continue
            
            # Construir √≠ndice de im√°genes (basename -> ruta completa)
            # Buscar en cualquier ubicaci√≥n, pero priorizar el subdirectorio correcto
            self._name_to_path = {}
            for name in zf.namelist():
                if name.endswith("/") or not name.lower().endswith((".jpg", ".jpeg", ".png")):
                    continue
                base = os.path.basename(name)
                # Priorizar im√°genes en el subdirectorio correcto (puede estar en cualquier nivel)
                # Buscar "Val_images" o "images_subdir" en cualquier parte de la ruta
                score = int(self.images_subdir.lower() in name.lower())
                # Bonus si est√° en el directorio ra√≠z detectado
                if self.zip_root_prefix and name.startswith(self.zip_root_prefix):
                    score += 1
                prev = self._name_to_path.get(base)
                if prev is None or score > prev[0]:
                    self._name_to_path[base] = (score, name)
            self._name_to_path = {k: v[1] for k, v in self._name_to_path.items()}
            
            # Construir candidatos por categor√≠a
            # Esto inicializa self.candidates_per_cat
            print(f"üìä Construyendo candidatos... Total muestras: {len(self.samples)}")
            self._build_candidates_by_category()
            
            # Limitar n√∫mero de muestras si se especifica
            if n_rows != "all":
                self.samples = self.samples[:int(n_rows)]
                # Reconstruir candidatos despu√©s de limitar muestras
                print(f"üìä Reconstruyendo candidatos despu√©s de limitar a {n_rows} muestras...")
                self._build_candidates_by_category()
        finally:
            # Cerrar el zip si fue abierto
            if zf:
                zf.close()
    
    def _infer_category_from_filename(self, filename: str) -> str:
        """
        Infiere la categor√≠a desde el nombre del archivo.
        
        Categor√≠as seg√∫n VQA-Med 2019:
        - C1_Modality_* ‚Üí "modality"
        - C2_Plane_* ‚Üí "plane"
        - C3_Organ_* ‚Üí "organ_system"
        - C4_Abnormality_* ‚Üí "abnormality"
        """
        basename = os.path.basename(filename).lower()
        
        if "c1" in basename or "modality" in basename:
            return "modality"
        elif "c2" in basename or "plane" in basename:
            return "plane"
        elif "c3" in basename or "organ" in basename:
            return "organ_system"
        elif "c4" in basename or "abnormality" in basename:
            return "abnormality"
        
        # No usar "other", lanzar error si no se puede inferir
        raise ValueError(f"No se pudo inferir categor√≠a desde el nombre de archivo: {filename}")
    
    def _build_candidates_by_category(self) -> Dict[str, List[str]]:
        """
        Construye la lista de candidatos v√°lidos por categor√≠a.
        Todas las respuestas √∫nicas de esa categor√≠a dentro del split.
        """
        candidates_by_category = defaultdict(set)
        
        for sample in self.samples:
            category = sample.get('category')
            answer = sample.get('answer')
            if category and answer:
                # Agregar respuesta a los candidatos de su categor√≠a
                candidates_by_category[category].add(answer)
        
        # Convertir sets a listas ordenadas
        self.candidates_per_cat = {
            category: sorted(list(answers))
            for category, answers in candidates_by_category.items()
        }
        
        # Debug: mostrar estad√≠sticas
        print(f"üìä Construyendo candidatos desde {len(self.samples)} muestras...")
        if self.candidates_per_cat:
            print(f"üìä Candidatos construidos por categor√≠a:")
            for cat, cands in self.candidates_per_cat.items():
                print(f"   {cat}: {len(cands)} candidatos")
                if len(cands) <= 10:
                    print(f"      Ejemplos: {cands[:5]}")
        else:
            print(f"‚ö†Ô∏è  ADVERTENCIA: No se construyeron candidatos. Muestras: {len(self.samples)}")
            if self.samples:
                print(f"   Primera muestra: {self.samples[0]}")
        
        return self.candidates_per_cat
    
    def __len__(self):
        return len(self.samples)
    
    def __getitem__(self, idx: int):
        sample = self.samples[idx]
        question = sample['question']
        answer = sample['answer']
        category = sample['category']
        question_id = sample['question_id']
        
        # Obtener candidatos para esta categor√≠a (no globales, solo de esta categor√≠a)
        # Asegurar que candidates_per_cat est√© inicializado
        if not hasattr(self, 'candidates_per_cat') or self.candidates_per_cat is None:
            self._build_candidates_by_category()
        
        candidates = self.candidates_per_cat.get(category, [])
        
        # Debug si no hay candidatos
        if not candidates:
            print(f"‚ö†Ô∏è  Advertencia: No se encontraron candidatos para categor√≠a '{category}'")
            print(f"   Categor√≠as disponibles: {list(self.candidates_per_cat.keys())}")
            print(f"   Total muestras: {len(self.samples)}")
        
        # Intentar encontrar la imagen asociada
        image_path = None
        image_filename = sample.get('image_filename')
        
        # Abrir el zip correcto (padre o hijo)
        if self.is_nested_zip:
            # Abrir el zip hijo desde memoria
            zf = zipfile.ZipFile(BytesIO(self.inner_zip_data), "r")
        else:
            # Abrir directamente el zip hijo
            zf = zipfile.ZipFile(self.zip_path, "r")
        
        try:
            # Estrategia 1: Si tenemos el nombre de imagen del archivo de preguntas
            if image_filename:
                # Buscar en el subdirectorio de im√°genes
                if self.images_subdir:
                    candidate = f"{self.images_subdir.rstrip('/')}/{image_filename}"
                    if candidate in zf.namelist():
                        image_path = candidate
                
                # Si no se encontr√≥, buscar por basename en el √≠ndice
                if image_path is None:
                    base = os.path.basename(image_filename)
                    image_path = self._name_to_path.get(base)
                
                # Si a√∫n no se encontr√≥, buscar por nombre completo
                if image_path is None:
                    candidates = [n for n in zf.namelist() 
                                if n.endswith(image_filename) or os.path.basename(n) == image_filename]
                    if candidates:
                        image_path = candidates[0]
            
            # Estrategia 2: Si no hay nombre de imagen, buscar por question_id
            if image_path is None:
                img_id = question_id.replace('Q', '').strip()
                candidates_paths = []
                for name in zf.namelist():
                    if not name.lower().endswith((".jpg", ".jpeg", ".png")):
                        continue
                    base = os.path.basename(name)
                    # Intentar coincidencia por ID en el nombre
                    if img_id in base or base.startswith(img_id):
                        candidates_paths.append(name)
                
                if candidates_paths:
                    image_path = candidates_paths[0]
            
            # Estrategia 3: √öltimo recurso - buscar cualquier imagen en el subdirectorio
            if image_path is None:
                for name in zf.namelist():
                    if self.images_subdir.lower() in name.lower() and name.lower().endswith((".jpg", ".jpeg", ".png")):
                        image_path = name
                        break
            
            if image_path is None:
                raise KeyError(
                    f"No se pudo encontrar imagen para {question_id}. "
                    f"Revisa la estructura del ZIP y el mapeo pregunta-imagen."
                )
            
            # Cargar imagen
            with zf.open(image_path) as f:
                image = Image.open(BytesIO(f.read())).convert("RGB")
        finally:
            # Cerrar el zip
            if zf:
                zf.close()
        
        return {
            "image": image,
            "question": question,
            "answer": answer,
            "category": category,
            "candidates": candidates,
            "meta": {
                "question_id": question_id,
                "image_path": image_path,
                "split": self.split
            }
        }

